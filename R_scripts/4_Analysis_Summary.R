# November 23 2021
# re-checking code for SSR

#Frist, we compare the PFT composition from the FIA data from 2010 (proportion basal area) with PFT composition predicted by LPJ-GUESS driven by 200 years of climate data, 1810-2010 (proporiton of basal area).
#Goal: 1. find values for growth_resp_cost (GRC) and fire_survival_mod (FSM) that produce output that fits the FIA data best
    #  2. find fire probability that fits FIA data best 

#------
# 1. Find values for growth_resp_cost (GRC) and fire_survival_mod (FSM) that produce output that fits the FIA data. LPJ-GUESS is driven by 200 years of climate data (1810-2010) with a single region-wide disturbance at the start of the run. Output is compared Forest Inventory and Analysis (FIA) data from 2010. Stand age is used to compare with simulation year (ie. a stand age of 10 would be compared with the output from the 10th LPJ-GUESS simulation year). For each plant functional type (PFT) the proportion of total leaf area index generated by LPJ-GUESS is compared with proportion of total basal area calculated from the FIA data set. Two methods for finding squared sum of residuals were used:
      # a. Best neighbor and nearest neighbor functions
      # b. find best value for GRC and FSM

# 2. Map fire probabilities with best fit: for each LPJ-GUESS grid point, find the output driven by a fire probability that produces the lowest squared sum of residuals.

# 3. For comparison with the witness tree data, a similar method to part 2 will be used. The major difference being the the witness tree data does not come with stand/tree age or with years in which each survey was taken. Instead there is a interval in which land surveys were taken for each state. 
# For each fire probability output, find the squared sum of residuals (SSR) at every grid point:
      # a. for each LPJ-GUESS coordinate, find the closest neighbors (currently using 5 neighbors, but this is an input for the function so it can changed).
      # b. find the neighbor with the lowest SSR. Do this by calculating residuals for each PFT at that grid point. For example, subtracting the proportion of TBIR (oak species) predicted by LPJ-GUESS from the proportion of TBIR found in the witness tree data. 
      # c. add the best SSR and associated PFT residuals to a data frame of residuals and SSR's for each grid point. 

# 4. Map fire probabilities with best fit for each LPJ-GUESS grid point. Do this by looping through a list of LPJ-GUESS grid points and finding the fire probability that yields the lowest SSR. 

#4. Compare the two fire maps.
#------

#------
#Libraries
library(ggplot2) #for plotting
library(dplyr) #changing data structure
library(plyr)#use aggreggate() funciton for changing data format
library(reshape2)#
library(tidyr)
library(tibble)
library(raster)
library(gstat)
library(caret) 
library(ggthemes)
library(ggplot2)
library(cowplot)
library(spdplyr)

#------
# read in LPJ-GUESS LAI data
# (to test these functions on)
#------
source("../R_scripts/functions/cleanup.R")

lai = cleanup(lai=read.table("/Users/charlotteuden/Desktop/trees/data/LPJ-GUESS_output/final_runs_11-01-2021/fire0-005-climate1200-grc-06-fsm-05/lai.out"),fireprob=0.005, distinterval=1, gcr=-0.6, fsm=1.5)
lai = cleanup(lai=read.table("/Users/charlotteuden/Desktop/trees/data/LPJ-GUESS_output/GRC_FSM/best_output/fire0-singledist-grc-06-fsm-06/lai.out"),fireprob=0, distinterval=1, gcr=-0.6, fsm=1.6)
cols <- c("Lat", "Lon", "year", "BNT", "BBI", "TBT", "TBI", "TBIR", "BNI")
lai <- lai[,cols]
lai[,c("Lat")] <- as.numeric(lai[,c("Lat")])
lai[,c("Lon")] <- as.numeric(lai[,c("Lon")])
lai <- mutate(lai, total=BNT+BBI+TBT+TBI+TBIR+BNI)
lai <- mutate(lai, BNT=BNT/total,BBI=BBI/total,TBT=TBT/total,TBI=TBI/total,TBIR=TBIR/total,BNI=BNI/total)
lai[is.na(lai)] <- 0
head(lai)
#------
# read in witness tree data
wit <- read.csv("../data/witness_trees/witness_treees_PFTs.csv")[,-1]
head(wit)
#read in FIA tree data
fia <- read.csv("../data/FIA/FIA_PFTs.csv")[,-1]
head(fia)
#------#------#------#------#------#------ 
#FIA ANALYSIS: find GRC, FSM and fire probability that matches FIA data, map best fit

# 1. nearest neighbor function 
      # INPUT: obs = observed data (FIA), pred = predicted data (LPJ-GUESS output)
      # OUTPUT: residuals for every PFT at every grid point for every stand age/simulation year

residuals_nearest_neighbor_FIA <- function(obs=x, pred=y) {
  
  #standardise pred
  pred <- mutate(pred, year=year-1809)
  pred <- mutate(pred, total=BNT+BBI+TBT+TBI+TBIR+BNI)
  pred <- mutate(pred, BNT=BNT/total,BBI=BBI/total,TBT=TBT/total,TBI=TBI/total,TBIR=TBIR/total,BNI=BNI/total)
  pred[is.na(pred)] <- 0
  
  # 1. make obs and pred spatial objects
  sp.obs <- obs
  sp.pred <- pred
  coordinates(sp.obs) <- ~Lon+Lat
  coordinates(sp.pred) <- ~Lon+Lat
  
  #2. make an empty data frame to hold the residuals
  resid <- data.frame(Lat=as.numeric(), 
                      Lon=as.numeric(), 
                      age=as.numeric(),
                      BNT=as.numeric(),
                      BBI=as.numeric(),
                      TBT=as.numeric(),
                      TBI=as.numeric(),
                      TBIR=as.numeric(),
                      BNI=as.numeric())
  
  # 3. for loop to take each row in fia data
  for (i in seq(from=1, to=nrow(fia_pft))){
    coord = sp.obs[i,]
    # 2. find the stand age of that row
    age = coord[,1]
    age = as.data.frame(age)[1,1]
    # 3. filter lai for the age/year 
    sp.pred.age = filter(sp.pred, year==age)
    #make sure there are values in sp.pred.age 
    if (nrow(as.data.frame(sp.pred.age)) == 0) {
      next
    }
    # 4. find the distance of all these lai points to the fia point
    distances <- pointDistance(coord, sp.pred.age, lonlat=TRUE, allpairs=FALSE)
    # 5. add distances to the predicted sp dataframe and plot to make sure it worked
    sp.pred.age$distances <- c(distances)
    #ggplot() + geom_point(data=as.data.frame(sp.pred.age), aes(x=Lon, y=Lat, size=distances))
    #get the minimum distance and its associated coordinates and attributes
    min_dist <- min(distances)
    nearest_neighbor = filter(as.data.frame(sp.pred.age), distances==min_dist)
    #get residual for each PFT and put it into a dataframe
    Lat = as.data.frame(coord)$Lat
    Lon = as.data.frame(coord)$Lon
    age = as.data.frame(coord)$age
    BNT = as.data.frame(coord)$BNT - nearest_neighbor$BNT
    BBI = as.data.frame(coord)$BBI - nearest_neighbor$BBI
    TBT = as.data.frame(coord)$TBT - nearest_neighbor$TBT
    TBI = as.data.frame(coord)$TBI - nearest_neighbor$TBI
    TBIR = as.data.frame(coord)$TBIR - nearest_neighbor$TBIR
    BNI = as.data.frame(coord)$BNI - nearest_neighbor$BNI
    #resid[i,] <- cbind(Lat, Lon, age, BNT, BBI, TBT, TBI, TBIR, BNI)
    resid <- rbind(resid, cbind(Lat, Lon, age, BNT, BBI, TBT, TBI, TBIR, BNI))
  }
  
  return(resid)
}

# 2. best of x neighbors function 
# INPUT: obs = observed data (FIA), pred = predicted data (LPJ-GUESS output), neighbors = number of neighbors in neighborhood
# OUTPUT: residuals for every PFT at every gridpoint for every stand age/simulation year

residuals_best_neighbor_in_neighborhood_FIA <- function(obs=x, pred=y, neighbors=z) {
  pred = lai
  obs = fia
  neighbors = 5
  #standardise pred
  pred <- mutate(pred, year=year-1809)
  pred <- mutate(pred, total=BNT+BBI+TBT+TBI+TBIR+BNI)
  pred <- mutate(pred, BNT=BNT/total,BBI=BBI/total,TBT=TBT/total,TBI=TBI/total,TBIR=TBIR/total,BNI=BNI/total)
  pred[is.na(pred)] <- 0
  
  #get fire probability, grc adn fsm
  fireprob = pred[1,c("fireprob")]
  grc = pred[1,c("grc")]
  fsm = pred[1,c("fsm")]
  
  # 1. make obs and pred spatial objects
  sp.obs <- obs#obs
  sp.pred <- pred#pred
  coordinates(sp.obs) <- ~Lon+Lat
  coordinates(sp.pred) <- ~Lon+Lat
  
  #2. make an empty data frame to hold the residuals
  resid <- data.frame(Lat=as.numeric(), 
                      Lon=as.numeric(), 
                      age=as.numeric(),
                      BNT=as.numeric(),
                      BBI=as.numeric(),
                      TBT=as.numeric(),
                      TBI=as.numeric(),
                      TBIR=as.numeric(),
                      BNI=as.numeric())
  
  # 3. for loop to take each row in fia data
  for (i in seq(from=1, to=nrow(obs))){
    #i=1
    coord = sp.obs[i,]
    # 2. find the stand age of that row
    age = coord[,1]
    age = as.data.frame(age)[1,1]
    # 3. filter lai for the age/year 
    sp.pred.age = filter(sp.pred, year==age)
    #make sure there are values in sp.pred.age 
    if (nrow(as.data.frame(sp.pred.age)) == 0) {
      next
    }
    # 4. find the distance of all these lai points to the fia point
    distances = pointDistance(coord, sp.pred.age, lonlat=TRUE, allpairs=FALSE)
    # 5. add distances to the predicted sp dataframe and plot to make sure it worked
    sp.pred.age$distances <- c(distances)
    #ggplot() + geom_point(data=as.data.frame(sp.pred.age), aes(x=Lon, y=Lat, size=distances))
    # 6. get the minimum n distances and their associated coordinates and variables 
    #(n=neighbors as input for this funciton)
    sp.pred.age = as.data.frame(sp.pred.age) %>% arrange(distances)
    neighbors_in_neighborhood = sp.pred.age[1:neighbors,]
    #get best neighbor from neighbors in neighborhood using SSR
    
    SSR_test = 100000000000
    
    for (j in seq(from=1, to=nrow(neighbors_in_neighborhood))){
      Lat = as.data.frame(coord)$Lat
      Lon = as.data.frame(coord)$Lon
      age = as.data.frame(coord)$age
      
      BNT = (as.data.frame(coord)$BNT) - (neighbors_in_neighborhood[j,]$BNT)
      BBI = (as.data.frame(coord)$BBI) - (neighbors_in_neighborhood[j,]$BBI)
      TBT = (as.data.frame(coord)$TBT) - (neighbors_in_neighborhood[j,]$TBT)
      TBI = (as.data.frame(coord)$TBI) - (neighbors_in_neighborhood[j,]$TBI)
      TBIR = (as.data.frame(coord)$TBIR) - (neighbors_in_neighborhood[j,]$TBIR)
      BNI = (as.data.frame(coord)$BNI) - (neighbors_in_neighborhood[j,]$BNI)
      
      SSR = sum(BNT^2, BBI^2, TBT^2, TBI^2, TBIR^2, BNI^2)
      
      if (SSR < SSR_test) {
        SSR_test = SSR
        current_resid <- cbind(Lat, Lon, age, BNT, BBI, TBT, TBI, TBIR, BNI)
      }
    }
    resid <- rbind(resid, current_resid)
  }
  resid = cbind(resid, fireprob=rep(fireprob, times=nrow(resid)), fsm=rep(fsm, times=nrow(resid)), grc=rep(grc, times=nrow(resid)))
  return(resid)
}

# 3. function to find Squared Sum of Residuals 
# INPUT: output from either residuals_best_neighbor_in_neighborhood_FIA() or residuals_nearest_neighbor_FIA()
# OUTPUT: squared sum of residuals for each lpj-guess grid point

get_SSR_PFT <- function(residuals=x){
  
  
  
  sum(BNT^2, BBI^2, TBT^2, TBI^2, TBIR^2, BNI^2)
  BNT = sum(residuals$BNT)^2
  BBI = sum(residuals$BBI)^2
  TBT = sum(residuals$TBT)^2
  TBI = sum(residuals$TBI)^2
  TBIR = sum(residuals$TBIR)^2
  BNI = sum(residuals$BNI)^2
  all_PFT = sum(BNT, BBI, TBT, TBI, TBIR, BNI)^2
  SSR <- data.frame(BNT=BNT, BBI=BBI, TBT=TBT, TBI=TBI, TBIR=TBIR, BNI=BNI, all_PFT=all_PFT)
  return(SSR)
}

# 4. Once best value for GRC and FSM (lowest SSR) has been found, map fire probabilities with best fit.
      #this will require another funciton that, is very similar to the best neighbor function, 
      #but instead of returning residuals for each FIA coordinate, it returns the SSR for each LPJ-GUESS coordinate.

get_SSR_byLPJpoint <- function(pred=x, obs=y, neighbors=z){
  #pred=lai
  #obs=fia
  #neighbors=5
  
  #becuase lpj-guess simulation is 200 years long, only want stand ages less than 200
  obs = filter(obs, age<200)
  
  #get fire probability, grc adn fsm
  fireprob = pred[1,c("fireprob")]
  grc = pred[1,c("grc")]
  fsm = pred[1,c("fsm")]
  #standardise pred
  pred <- mutate(pred, total=BNT+BBI+TBT+TBI+TBIR+BNI)
  pred <- mutate(pred, BNT=BNT/total,BBI=BBI/total,TBT=TBT/total,TBI=TBI/total,TBIR=TBIR/total,BNI=BNI/total)
  pred[is.na(pred)] <- 0
  pred <- mutate(pred, year=year-1809)
  
  # 1. make obs and pred spatial objects
  sp.obs <- obs#obs
  sp.pred <- pred#pred
  coordinates(sp.obs) <- ~Lon+Lat
  coordinates(sp.pred) <- ~Lon+Lat
  
  #2. make an empty data frame to hold the squared sum of residuals
  ssr <- data.frame(Lat=as.numeric(), 
                      Lon=as.numeric(), 
                      BNT=as.numeric(),
                      BBI=as.numeric(),
                      TBT=as.numeric(),
                      TBI=as.numeric(),
                      TBIR=as.numeric(),
                      BNI=as.numeric(),
                      SSR=as.numeric())
  #get lpj-guess coordinates
  coords = unique(pred[,c("Lat","Lon")])
  coordinates(coords) <- ~Lon+Lat
  # 3. for loop to take each lpj-guess coordinate
  for (i in seq(from=1, to=nrow(as.data.frame(coords)))){
    #i=5
    coord = coords[i,]
    # 2. find the n closest neighbors
    distances = pointDistance(coord, sp.obs, lonlat=TRUE, allpairs=FALSE)
    obs_distances = sp.obs
    obs_distances$distances <- c(obs_distances)
    obs_distances = as.data.frame(obs_distances) %>% arrange(distances)
    neighbors_in_neighborhood = sp.obs[1:neighbors,]
    # 3. filter for lpj-guess data points that are the same simulation year as the stand ages of those five points
    ages = c(neighbors_in_neighborhood$age)
    pred.age = filter(pred, Lat==as.data.frame(coord)[,2], Lon==as.data.frame(coord)[,1], (year==ages[1] | year==ages[2] | year==ages[3] | year==ages[4] | year==ages[5]))
    # 4. find which neighbor in the neighborhood has the lowest SSR
    # something to hold the smallest SSR and something to hold residuals and coords for current lowest ssr
    SSR_smallest = 1000000000
    current_resid = as.numeric()
    
    for (j in seq(from=1, to=length(ages), by=1)){
      #j = 1
      #filter both data sets for j age in ages
      neighbor = filter(neighbors_in_neighborhood, age==ages[j])
      pred_point = filter(pred.age, year==ages[j])
      #get residuals
      BNT = (neighbor$BNT-pred_point$BNT)
      BBI = (neighbor$BBI-pred_point$BBI)
      TBT = (neighbor$TBT-pred_point$TBT)
      TBI = (neighbor$TBI-pred_point$TBI)
      TBIR = (neighbor$TBIR-pred_point$TBIR)
      BNI = (neighbor$BNI-pred_point$BNI)
      #find squared sum of residuals
      SSR = sum(BNT, BBI, TBT, TBI, TBIR, BNI)^2
      
      if (SSR < SSR_smallest) {
        SSR_smallest = SSR
        current_resid = cbind(Lat = as.data.frame(coord)[,2], Lon = as.data.frame(coord)[,1], BNT, BBI, TBT, TBI, TBIR, BNI, SSR) 
      }
    }
    # after looping through neighbors, as neighbor with lowest SSR to resid (lat, lon, residuals for each PFT and SSR for that grid point):
    ssr <- rbind(ssr, current_resid)
  }
  ssr = cbind(ssr, fireprob=rep(fireprob, times=nrow(ssr)), fsm=rep(fsm, times=nrow(ssr)), grc=rep(grc, times=nrow(ssr)))
  
  return(ssr)
}

test = get_SSR_byLPJpoint(pred=lai, obs=fia, neighbors = 5)
head(test)
    
# 5. After running this function in babage on all fire probabilities at grc and fsm with best fit, find which fire probability has the lowest ssr at each lpj-guess coordinate:
        #make empty data frame to hold the coordinates and associated variables with the best SSR

df <- data.frame(Lat=as.numeric(),
                 Lon=as.numeric(),
                 BNT=as.numeric(), 
                 BBI=as.numeric(),
                 TBT=as.numeric(),
                 TBI=as.numeric(),
                 TBIR=as.numeric(),
                 BNI=as.numeric(), 
                 SSR=as.numeric(),
                 fire=as.numeric())
#for each unique coordinate, find lowest SSR 
coords = unique(lpj_residuals[,1:2])
for (i in seq(1, nrow(coords))){
  #i=1
  coord = coords[i,]
  x = filter(lpj_residuals, Lat==coord[1,1] & Lon==coord[1,2])
  x = filter(x, SSR==min(x$SSR))
  #add coordinate and its associated fire probability and SSR to a data frame 
  df = rbind(df, x)
}
# plot the results
ggplot() + geom_point(data=df, aes(x=Lat_pred, y=Lon_pred, size=fire_prob, alpha=0.1)) + scale_size('fire probability', breaks=c(1, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0), range=c(0,20)) + ggtitle("Witness Tree Best Fit")

#------#------#------#------#------#------ 
#WITNESS TREE ANALYSIS: find fire probability that matches FIA data, map best fit

# 1. for each fire probability output, find the squared sum of residuals (SSR) at every grid point. 
    # - do this using the best neighbor function used for the FIA data. 
    # - will need to add a year interval for each state, since the witness tree data only has ranges of years that the surveys were taken

residuals_best_neighbor_witness_trees <- function(obs=x, pred=y, neighbors=z) {
  # for testing the function:
  obs = wit
  pred = lai
  neighbors = 5
  
  #standardise pred
  pred <- mutate(pred, total=BNT+BBI+TBT+TBI+TBIR+BNI)
  pred <- mutate(pred, BNT=BNT/total,BBI=BBI/total,TBT=TBT/total,TBI=TBI/total,TBIR=TBIR/total,BNI=BNI/total)
  pred[is.na(pred)] <- 0
  
  # 1. make obs and pred spatial objects
  sp.obs <- obs#obs
  sp.pred <- pred#pred
  coordinates(sp.obs) <- ~Lon+Lat
  coordinates(sp.pred) <- ~Lon+Lat
  
  #2. make an empty data frame to hold the residuals
  resid <- data.frame(Lat=as.numeric(), 
                      Lon=as.numeric(), 
                      BNT=as.numeric(),
                      BBI=as.numeric(),
                      TBT=as.numeric(),
                      TBI=as.numeric(),
                      TBIR=as.numeric(),
                      BNI=as.numeric())
  
  # 3. vector of unique lpj-guess coordinates to loop though, make it a spatial object
  coords = unique(pred[c("Lat", "Lon")])
  coordinates(coords) <- ~Lon+Lat
  #4. take each coordinate in lpj guess 
  #nrow(as.data.frame(coords))) # there area 123 coodinates
  for (i in seq(from=1, to=123)){
    i = 13
    coord = coords[i,]
    # 5. find the five closest witness tree points
    distances = pointDistance(coord, sp.obs, lonlat=TRUE, allpairs=FALSE)
    # 6. add distances to the predicted sp dataframe and plot to make sure it worked
    sp.obs$distances <- c(distances)
    #plot to check that distances have been correctly added:
    #ggplot() + geom_point(data=as.data.frame(sp.obs), aes(x=Lon, y=Lat, size=distances))
    
    # 7. get the minimum n distances and their associated coordinates and variables 
    #(n=neighbors as input for this function)
    obs_neighbors = as.data.frame(sp.obs) %>% arrange(distances)
    neighbors_in_neighborhood = obs_neighbors[1:neighbors,]
     # 8. for each witness tree of the 5 points (neighbors), 
        # take the year interval
        # filter lpj-guess for that interval (just the current coord we are working with)
        # calculate residuals for each pft, sum them and square them 
        # if SSR is greater than previously calculated ssr, replace 'SSR with that 'best_fit' with that row
    
    # something to hold the smallest SSR and something to hold residuals and coords for current lowest ssr
    SSR_smallest = 1000000000
    current_resid = as.numeric()
    for (j in seq(from=1, to=neighbors)){
      #j = 1
      start = neighbors_in_neighborhood[j,11]
      end = neighbors_in_neighborhood[j,12]
      #filter pred for current coordinate point
      pred_current = filter(as.data.frame(sp.pred), Lon==as.data.frame(coord)[,1] & Lat==as.data.frame(coord)[,2])
      #filter pred for start and end years
      pred_current = filter(pred_current, between(year, start, end)) 
      #get residuals
      BNT = (neighbors_in_neighborhood[j,]$BNT-mean(as.data.frame(pred_current)$BNT))
      BBI = (neighbors_in_neighborhood[j,]$BBI-mean(as.data.frame(pred_current)$BBI))
      TBT = (neighbors_in_neighborhood[j,]$TBT-mean(as.data.frame(pred_current)$TBT))
      TBI = (neighbors_in_neighborhood[j,]$TBI-mean(as.data.frame(pred_current)$TBI))
      TBIR = (neighbors_in_neighborhood[j,]$TBIR-mean(as.data.frame(pred_current)$TBIR))
      BNI = (neighbors_in_neighborhood[j,]$BNI-mean(as.data.frame(pred_current)$BNI))
      #find squared sum of residuals
      SSR = sum(BNT^2, BBI^2, TBT^2, TBI^2, TBIR^2, BNI^2)

      if (SSR < SSR_smallest) {
        SSR_smallest = SSR
        current_resid = cbind(Lat = as.data.frame(coord)[,2], Lon = as.data.frame(coord)[,1], BNT, BBI, TBT, TBI, TBIR, BNI, SSR) 
      }
    }
    # after looping through neighbors, as neighbor with lowest SSR to resid (lat, lon, residuals for each PFT and SSR for that grid point):
    resid <- rbind(resid, current_resid)
  }
  return(resid)
}

resid_test <- residuals_best_neighbor_witness_trees(obs=wit, pred=lai, neighbors=5)
ggplot() + geom_point(data=resid_test, aes(x=Lon, y=Lat, size=SSR))                

# 2. run residuals_best_neighbor_witness_trees() on babage (where the data is) for each LPJ-GUESS fire probability output:
        # fire probability = 0, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 1

# 3. rbind() all SSR 'maps'. For each gridpoint, find the lowest SSR:
  
  #make empty data frame to hold the coordinates and associated variables with the best SSR
df <- data.frame(Lat=as.numeric(),
                 Lon=as.numeric(),
                 BNT=as.numeric(), 
                 BBI=as.numeric(),
                 TBT=as.numeric(),
                 TBI=as.numeric(),
                 TBIR=as.numeric(),
                 BNI=as.numeric(), 
                 SSR=as.numeric(),
                 fire=as.numeric())
  #for each unique coordinate, find lowest SSR 
coords = unique(lpj_residuals[,1:2])
for (i in seq(1, nrow(coords))){
  #i=1
  coord = coords[i,]
  x = filter(lpj_residuals, Lat==coord[1,1] & Lon==coord[1,2])
  x = filter(x, SSR==min(x$SSR))
  #add coordinate and its associated fire probability and SSR to a data frame 
  df = rbind(df, x)
}
  
  # plot with point size = fire probability:
ggplot() + geom_point(data=df_wit, aes(x=Lat_pred, y=Lon_pred, size=fire, alpha=0.1)) + scale_size('fire probability', breaks=c(1, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0), range=c(0,20)) + ggtitle("Witness Tree Best Fit")


#------#------#------#------#------#------ 
#--- Compare the two fire maps ---
  
# To look at change in fire regimes since pre-Euro contact, make a data frame of increase/decrease in fire... 

fire_change 





